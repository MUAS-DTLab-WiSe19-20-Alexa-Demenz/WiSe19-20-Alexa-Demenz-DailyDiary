package dailydiary.models;

import java.util.Date;
import java.util.List;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTypeConvertedTimestamp;

import dailydiary.extension.DateTimeExtenstion;

/**
 * 
 * A class to create events containing a name, a description, a location,
 * participants and a date.
 * 
 */
public class Event extends DynamoDBEntity {
	
	private String name = "";
	private String description = "";
	private String location = "";
	private List<Participant> participants;
	private Date date = new Date(System.currentTimeMillis());

	/**
	 * Constructor for Events
	 * 
	 */
	public Event() { }

	/** 
	 * Constructor for Events
	 * 
	 * @param name
	 * @param date
	 */
	public Event(String name, String description, String location, List<Participant> participants, Date date) {
		setName(name);
		setDescription(description);
		setLocation(location);
		setParticipants(participants);
		setDate(date);
	}
	
	@Override
    @DynamoDBAttribute(attributeName="userId") 
	public String getUserId() { return super.getUserId(); }
	
	@Override
	@DynamoDBHashKey(attributeName="id") 
	@DynamoDBAutoGeneratedKey
	public String getId() { return super.getId(); }
	
	/**
	 * Getter for event-names
	 * 
	 * @return name
	 */
    @DynamoDBAttribute(attributeName="name") 
	public String getName() { return this.name; }
    
	/**
	 * Setter for event-names
	 * 
	 */
	public void setName(String name) { this.name = name == null ? null : name.toLowerCase(); }

	/**
	 * Getter for event-Description
	 * 
	 * @return description
	 */
    @DynamoDBAttribute(attributeName="description") 
    public String getDescription() { return this.description; }
    
	/**
	 * Setter for event-Description
	 * 
	 */
	public void setDescription(String description) { this.description = description == null ? null : description.toLowerCase(); }

	/**
	 * Getter for event-location
	 * 
	 */
    @DynamoDBAttribute(attributeName="location") 
    public String getLocation() { return this.location; }
    
	/**
	 * Setter for event-location
	 * 
	 */
	public void setLocation(String location) { this.location = location == null ? null : location.toLowerCase(); }

	/**
	 * Getter for event-participants
	 * 
	 * @return participants
	 */
    @DynamoDBAttribute(attributeName="participants") 
	public List<Participant> getParticipants() { return participants; }
    
	/**
	 * Setter for event-participants
	 * 
	 */
	public void setParticipants(List<Participant> participants) { this.participants = participants; }
	
	/**
	 * Getter for event-date
	 * 
	 * @return date
	 */
	@DynamoDBTypeConvertedTimestamp(pattern=DynamoDBTable.DATE_FORMAT, timeZone="UTC")
	public Date getDate() { return this.date; }
	
	/**
	 * Setter for event-date
	 * 
	 */
	public void setDate(Date date) { this.date = date; }

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + ((description == null) ? 0 : description.hashCode());
		result = prime * result + ((location == null) ? 0 : location.hashCode());
		result = prime * result + ((participants == null) ? 0 : participants.hashCode());
		result = prime * result + ((date == null) ? 0 : date.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		
		if (obj == null)
			return false;
		
		if (getClass() != obj.getClass())
			return false;
		
		Event other = (Event) obj;
		
		if (!equalHeader(other))
			return false;
		
		return equalContent(other);
	}
	
	private boolean equalHeader(Event other) {	
		if (name == null) {
			if (other.name != null) return false;
		} else if (!name.equals(other.name)) return false;
		
		if (date == null) {
			if (other.date != null) return false;
		} else if (!date.equals(other.date)) return false;
		
		return true;
	} 
	
	private boolean equalContent(Event other) {	
		if (description == null) {
			if (other.description != null) return false;
		} else if (!description.equals(other.description)) return false;
		
		if (location == null) {
			if (other.location != null) return false;
		} else if (!location.equals(other.location)) return false;
		
		if (participants == null) {
			if (other.participants != null) return false;
		} else if (!participants.equals(other.participants)) return false;
		
		return true;
	} 

	@Override
	public String toString() {
		return "Event [name=" + name
				+ ", description=" + description
				+ ", location=" + location
				+ ", participants=" + participants
				+ ", date=" + date + "]";
	}

	/**
	 * Returns the event as speech text
	 * 
	 * @return speech
	 */
	public String toSpeech() {
		Date dateDT = date == null ? new Date(0) : date; 
		String dateD = DateTimeExtenstion.getFormaterDate().format(dateDT);
		String dateT = DateTimeExtenstion.getFormaterTime().format(dateDT);
		StringBuilder p = new StringBuilder();
		String d = "";
		String l = "";
		
		if (description != null && !description.isEmpty())
		    d = " Die Beschreibung lautet " + description + ".";
		
		if (location != null && !location.isEmpty())
		    l = " in " + location;
		
		if (participants != null && !participants.isEmpty()) {
			p.append(" Teilgenommen haben " + participants.get(0).getName());
			
			for (int i = 1; i < participants.size() - 1; i++)
				p.append(", " + participants.get(i).getName());
			
			if (participants.size() > 1)
				p.append(" und " + participants.get(participants.size() - 1).getName());
			
			p.append(".");
		}

		return String.format("Der Eintrag %s fand am %s um %s%s statt.%s%s", 
				name, 
				dateD, 
				dateT, 
				l, 
				p,
				d);
	}
}
